import xlsx from "xlsx";
import VulnerabilityReport from "../models/vulnerabilityReport.model.js";
import { OrganizationUser } from "../models/organisationUser.model.js";
import mongoose from "mongoose";
import { v4 as uuidv4 } from "uuid";
import { format, parse } from "date-fns";

export const uploadVulnerabilityReport = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: "No file uploaded" });
    }

    const buffer = req.file.buffer;
    const workbook = xlsx.read(buffer, { type: "buffer" });

    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const data = xlsx.utils.sheet_to_json(worksheet);
    console.log("Parsed data:", data);

    const userId = req.user._id;
    const reportDate = new Date();
    const uploadBatchId = uuidv4();

    const originalFileName = req.file.originalname.replace(/\.[^/.]+$/, ""); // strip extension
    const formattedDate = format(new Date(), "yyyy-MM-dd hh:mm a");
    const batchName = `${originalFileName}-${formattedDate}`;

    const reports = data.map((row) => ({
      serialNumber: row["Sl #"] || null,
      userId,
      description: row["Description"] || "",
      assessmentArea: row["Vulnerability Assessment Area"] || "",
      url: row["URL"] || "",
      impact: row["Impact "] || "",
      severity: row["Severity"] || "",
      recommendation: row["Recommendation"] || "",
      date: parse(row["Date"], 'dd.MM.yyyy', new Date()),
      assessmentArea: row["Application Type"] || "",
      reportDate,
      uploadBatchId,
      batchName,
      priority: row["Severity"] || "",
      status: "In Progress"
    }));

    await VulnerabilityReport.insertMany(reports);

    res.status(200).json({
      message: "Vulnerability report uploaded successfully",
      uploadBatchId,
      batchName,
      count: reports.length,
    });
  } catch (error) {
    console.error("Upload error:", error);
    res.status(500).json({ message: "Failed to upload vulnerability report", error });
  }
};

export const getUserVulnerabilityReportBatches = async (req, res) => {
  try {
    const userId = req.user._id;
    const currentUser = await OrganizationUser.findById(userId).lean();
    if (!currentUser) {
      return res.status(404).json({ message: "User not found" });
    }

    const orgUsers = await OrganizationUser.find({
      organisationName: currentUser.organisationName,
    }).select("_id");

    const userIds = orgUsers.map(u => new mongoose.Types.ObjectId(u._id));
    const batches = await VulnerabilityReport.aggregate([
      { $match: { userId: { $in: userIds } } },
      {
        $group: {
          _id: "$uploadBatchId",
          reportDate: { $first: "$reportDate" },
          batchName: { $first: "$batchName" },
        },
      },
      {
        $project: {
          _id: 0,
          uploadBatchId: "$_id",
          reportDate: 1,
          batchName: 1,
        },
      },
      { $sort: { reportDate: -1 } }, // recent first
    ]);

    res.status(200).json({ batches });
  } catch (error) {
    console.error("Error fetching batches:", error);
    res.status(500).json({ message: "Failed to fetch upload batches", error });
  }
};;

export const getVulnerabilityReportByBatch = async (req, res) => {
  try {
    const userId = req.user._id;
    const { batchId } = req.params;

    if (!batchId) {
      return res.status(400).json({ message: "Batch ID is required" });
    }

    // 1. Get the logged-in user
    const user = await OrganizationUser.findById(userId);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // 2. Get the organisation name of this user
    const orgName = user.organisationName;
    if (!orgName) {
      return res.status(400).json({ message: "User has no organisation assigned" });
    }

    // 3. Find all users in this organisation
    const usersInOrg = await OrganizationUser.find({ organisationName: orgName }).select("_id");

    const orgUserIds = usersInOrg.map(u => u._id);

    // 4. Get vulnerability reports for those users in the given batch
    const reports = await VulnerabilityReport.find({
      userId: { $in: orgUserIds },
      uploadBatchId: batchId,
    }).sort({ serialNumber: 1 });

    if (!reports || reports.length === 0) {
      return res.status(404).json({ message: "No reports found for this batch in your organisation" });
    }

    res.status(200).json({ reports });

  } catch (error) {
    console.error("Error fetching report details by batch:", error);
    res.status(500).json({ message: "Failed to fetch report details", error });
  }
};

export const updateSeverityBulk = async (req, res) => {
  try {
    const updates = req.body; // Expecting array like [{ _id, priority }, ...]

    if (!Array.isArray(updates) || updates.length === 0) {
      return res.status(400).json({ message: "No update data provided." });
    }

    const bulkOps = updates.map(item => {
      // console.log("Preparing bulk operation for item:", item)
      return ({
        updateOne: {
          filter: { _id: item._id },
          update: { $set: { priority: item.priority, status: item.status } }
        }
      })
    });

    const result = await VulnerabilityReport.bulkWrite(bulkOps);

    res.status(200).json({
      message: "Severity updated successfully for selected items.",
      result,
    });
  } catch (error) {
    console.error("Error updating severity in bulk:", error);
    res.status(500).json({ message: "Failed to update severity", error });
  }
};

